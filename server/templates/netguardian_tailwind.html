<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetGuardian Pro - Network Traffic Analyzer</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <!-- Feather Icons -->
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>

    <!-- AOS Animation Library -->
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>

    <!-- Feature Calculation Utilities -->
    <script src="/static/js/feature_utils.js"></script>

    <style>
        body {
            background: #0f1419;
        }

        .stat-card {
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
        }

        /* Color-specific hover glows */
        .stat-card.from-blue-900:hover {
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }

        .stat-card.from-purple-900:hover {
            box-shadow: 0 8px 20px rgba(168, 85, 247, 0.4);
        }

        .stat-card.from-green-900:hover {
            box-shadow: 0 8px 20px rgba(34, 197, 94, 0.4);
        }

        .stat-card.from-red-900:hover {
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }

        .stat-card.from-orange-900:hover {
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.4);
        }

        .stat-card.from-cyan-900:hover {
            box-shadow: 0 8px 20px rgba(6, 182, 212, 0.4);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .nav-link.active {
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }
    </style>
</head>

<body class="text-gray-100">

    <!-- Top Navigation -->
    <nav class="bg-gray-900 border-b border-gray-800 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <!-- Logo -->
                <div class="flex items-center space-x-3">
                    <div class="bg-gradient-to-br from-blue-500 to-blue-700 p-2 rounded-lg">
                        <i data-feather="shield" class="w-6 h-6"></i>
                    </div>
                    <span class="text-xl font-bold">NetGuardian Pro</span>
                </div>

                <!-- Navigation Links -->
                <div class="flex space-x-2">
                    <a href="#" class="nav-link px-4 py-2 rounded-lg text-sm font-medium transition active"
                        onclick="showPage('dashboard')">Dashboard</a>
                    <a href="#"
                        class="nav-link px-4 py-2 rounded-lg text-sm font-medium text-gray-400 hover:text-white transition"
                        onclick="showPage('analytics')">Analytics</a>
                    <a href="#"
                        class="nav-link px-4 py-2 rounded-lg text-sm font-medium text-gray-400 hover:text-white transition"
                        onclick="showPage('security')">Security</a>
                    <a href="#"
                        class="nav-link px-4 py-2 rounded-lg text-sm font-medium text-gray-400 hover:text-white transition"
                        onclick="showPage('performance')">Performance</a>
                    <a href="#"
                        class="nav-link px-4 py-2 rounded-lg text-sm font-medium text-gray-400 hover:text-white transition"
                        onclick="showPage('packets')">Packets</a>
                </div>

                <!-- Right Side -->
                <div class="flex items-center space-x-6">
                    <span id="last-updated" class="text-sm text-gray-400 hidden md:block">--:--:--</span>

                    <div class="flex items-center space-x-2 bg-gray-800 px-3 py-1 rounded-full border border-gray-700">
                        <div id="db-status-indicator" class="w-2 h-2 bg-gray-500 rounded-full"></div>
                        <span id="db-status-text" class="text-xs text-gray-400">Checking...</span>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">

        <!-- ==================== DASHBOARD PAGE ==================== -->
        <div id="dashboard-page" class="page active">
            <!-- Page Header -->
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold">Traffic Dashboard</h1>
                <div class="flex space-x-3">
                    <select id="timeRangeSelector" onchange="updateTimeRange()"
                        class="bg-gray-800 border border-gray-700 rounded-lg px-4 py-2 text-sm">
                        <option value="0.5">Last 30 Minutes</option>
                        <option value="24" selected>Last 24 hours</option>
                        <option value="168">Last 7 days</option>
                        <option value="720">Last 30 days</option>
                    </select>
                    <button onclick="exportExecutiveSummary()"
                        class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm font-medium flex items-center space-x-2">
                        <i data-feather="download" class="w-4 h-4"></i>
                        <span>Export Report</span>
                    </button>
                </div>
            </div>

            <!-- Main Stats - 4 Cards -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="stat-card bg-gradient-to-br from-blue-900 to-blue-800 rounded-xl p-6 shadow-lg"
                    data-aos="fade-up">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Peak Traffic</h3>
                            <p id="peakTraffic" class="text-3xl font-bold mt-2">--</p>
                            <p id="peakTrafficTime" class="text-xs text-gray-400 mt-1">Maximum rate</p>
                        </div>
                        <div class="bg-blue-500 p-3 rounded-lg">
                            <i data-feather="trending-up" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span id="peakTrafficChange" class="text-green-400">--</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-purple-900 to-purple-800 rounded-xl p-6 shadow-lg"
                    data-aos="fade-up" data-aos-delay="100">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Avg Traffic</h3>
                            <p id="avgTraffic" class="text-3xl font-bold mt-2">--</p>
                            <p id="avgTrafficLabel" class="text-xs text-gray-400 mt-1">Last 24 hours</p>
                        </div>
                        <div class="bg-purple-500 p-3 rounded-lg">
                            <i data-feather="activity" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span id="avgTrafficChange" class="text-green-400">--</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-green-900 to-green-800 rounded-xl p-6 shadow-lg"
                    data-aos="fade-up" data-aos-delay="200">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Total Packets</h3>
                            <p id="totalPackets" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Processed today</p>
                        </div>
                        <div class="bg-green-500 p-3 rounded-lg">
                            <i data-feather="package" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span id="totalPacketsChange" class="text-green-400">--</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-red-900 to-red-800 rounded-xl p-6 shadow-lg"
                    data-aos="fade-up" data-aos-delay="300">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Active Connections</h3>
                            <p id="activeConnections" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Live connections</p>
                        </div>
                        <div class="bg-red-500 p-3 rounded-lg">
                            <i data-feather="zap" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span id="activeConnectionsChange" class="text-green-400">--</span>
                    </div>
                </div>
            </div>

            <!-- Mini Stats - 5 Cards -->
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-8">
                <div class="bg-gray-800 rounded-lg p-4 text-center border border-gray-700">
                    <p id="packetLoss" class="text-2xl font-bold text-yellow-400">--</p>
                    <p class="text-xs text-gray-400 mt-1">Packet Loss</p>
                </div>
                <div class="bg-gray-800 rounded-lg p-4 text-center border border-gray-700">
                    <p id="avgLatency" class="text-2xl font-bold text-cyan-400">--</p>
                    <p class="text-xs text-gray-400 mt-1">Avg Latency</p>
                </div>
                <div class="bg-gray-800 rounded-lg p-4 text-center border border-gray-700">
                    <p id="bandwidthUsage" class="text-2xl font-bold text-green-400">--</p>
                    <p class="text-xs text-gray-400 mt-1">Bandwidth Usage</p>
                </div>
                <div class="bg-gray-800 rounded-lg p-4 text-center border border-gray-700">
                    <p id="tcpTraffic" class="text-2xl font-bold text-purple-400">--</p>
                    <p class="text-xs text-gray-400 mt-1">TCP Traffic</p>
                </div>
                <div class="bg-gray-800 rounded-lg p-4 text-center border border-gray-700">
                    <p id="packetsSec" class="text-2xl font-bold text-pink-400">--</p>
                    <p class="text-xs text-gray-400 mt-1">Packets/sec</p>
                </div>
            </div>

            <!-- Charts Row 1 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Traffic Volume Over Time</h3>
                    <div class="h-80">
                        <canvas id="trafficVolumeChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Protocol Distribution</h3>
                    <div class="h-80">
                        <canvas id="protocolChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Charts Row 2 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Protocol Traffic Trends</h3>
                    <div class="h-80">
                        <canvas id="protocolTrendChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Packet Size Distribution</h3>
                    <div class="h-80">
                        <canvas id="packetSizeChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Tables Row -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Top Source IPs</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm" id="top-sources-table">
                            <thead>
                                <tr class="border-b border-gray-700">
                                    <th class="text-left py-2 text-gray-400">IP Address</th>
                                    <th class="text-left py-2 text-gray-400">Packets</th>
                                    <th class="text-left py-2 text-gray-400">%</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td colspan="3" class="text-center py-4 text-gray-500">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Top Destination IPs</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm" id="top-destinations-table">
                            <thead>
                                <tr class="border-b border-gray-700">
                                    <th class="text-left py-2 text-gray-400">IP Address</th>
                                    <th class="text-left py-2 text-gray-400">Packets</th>
                                    <th class="text-left py-2 text-gray-400">%</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td colspan="3" class="text-center py-4 text-gray-500">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Top Ports Usage</h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm" id="top-ports-table">
                            <thead>
                                <tr class="border-b border-gray-700">
                                    <th class="text-left py-2 text-gray-400">Port</th>
                                    <th class="text-left py-2 text-gray-400">Service</th>
                                    <th class="text-left py-2 text-gray-400">%</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td colspan="3" class="text-center py-4 text-gray-500">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== ANALYTICS PAGE ==================== -->
        <div id="analytics-page" class="page">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold">Advanced Analytics</h1>
                <button onclick="generateAnalyticsReport()"
                    class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm font-medium flex items-center space-x-2">
                    <i data-feather="bar-chart-2" class="w-4 h-4"></i>
                    <span>Generate Report</span>
                </button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="stat-card bg-gradient-to-br from-blue-900 to-blue-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Network Health</h3>
                            <p id="analyticsHealth" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Overall score (0-100)</p>
                        </div>
                        <div class="bg-blue-500 p-3 rounded-lg">
                            <i data-feather="heart" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Excellent</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-purple-900 to-purple-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Connection Quality</h3>
                            <p id="analyticsQuality" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Quality index</p>
                        </div>
                        <div class="bg-purple-500 p-3 rounded-lg">
                            <i data-feather="wifi" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">High quality</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-green-900 to-green-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Protocol Diversity</h3>
                            <p id="analyticsDiversity" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Entropy score (0-1)</p>
                        </div>
                        <div class="bg-green-500 p-3 rounded-lg">
                            <i data-feather="layers" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Diverse</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-orange-900 to-orange-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Traffic Efficiency</h3>
                            <p id="analyticsEfficiency" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Efficiency ratio</p>
                        </div>
                        <div class="bg-orange-500 p-3 rounded-lg">
                            <i data-feather="zap" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Optimized</span>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Network Health Gauge</h3>
                    <div class="h-80">
                        <canvas id="healthGaugeChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Connection Success Rate</h3>
                    <div class="h-80">
                        <canvas id="connectionSuccessChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">TCP Flags Analysis</h3>
                    <div class="h-80">
                        <canvas id="tcpFlagsChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">DNS Activity Analysis</h3>
                    <div class="h-80">
                        <canvas id="dnsAnalysisChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                <div class="flex flex-col md:flex-row justify-between items-center mb-6">
                    <h3 class="text-lg font-semibold">All 63 Features</h3>
                    <div class="flex gap-2 w-full md:w-auto mt-4 md:mt-0">
                        <input type="text" id="featureIpInput" placeholder="Filter by IP..."
                            onkeyup="if(event.key==='Enter') loadIPFeatures()"
                            class="bg-gray-700 text-white px-3 py-1 rounded text-sm border border-gray-600 focus:outline-none focus:border-blue-500 w-full md:w-48">
                        <button onclick="loadIPFeatures()"
                            class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm text-white">Inspect</button>
                        <button onclick="loadFeatures()"
                            class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-sm text-white">Reset</button>
                    </div>
                </div>
                <div id="features-container">
                    <p class="text-center text-gray-500 py-8">Loading features...</p>
                </div>
            </div>
        </div>

        <!-- ==================== SECURITY PAGE ==================== -->
        <div id="security-page" class="page">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold">Security & Threat Detection</h1>
                <button onclick="generateSecurityReport()"
                    class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm font-medium flex items-center space-x-2">
                    <i data-feather="lock" class="w-4 h-4"></i>
                    <span>Security Report</span>
                </button>
            </div>

            <div id="security-alert"
                class="bg-gradient-to-r from-green-900 to-green-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-green-700">
                <div class="alert-icon bg-green-500 p-3 rounded-lg">
                    <i data-feather="check-circle" class="w-8 h-8"></i>
                </div>
                <div>
                    <h3 id="security-status" class="text-xl font-bold">All Clear</h3>
                    <p id="security-message" class="text-gray-300 mt-1">No threats detected. Network operating normally.
                    </p>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="stat-card bg-gradient-to-br from-blue-900 to-blue-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">ML Detection Status</h3>
                            <p id="mlAttackType" class="text-3xl font-bold mt-2">Normal</p>
                            <p class="text-xs text-gray-400 mt-1">AI-powered detection</p>
                        </div>
                        <div class="bg-blue-500 p-3 rounded-lg">
                            <i data-feather="cpu" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Monitoring</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-purple-900 to-purple-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">ML Confidence</h3>
                            <p id="mlConfidence" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Prediction confidence</p>
                        </div>
                        <div class="bg-purple-500 p-3 rounded-lg">
                            <i data-feather="target" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">High accuracy</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-orange-900 to-orange-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Threat Level</h3>
                            <p id="mlThreatLevel" class="text-3xl font-bold mt-2">NONE</p>
                            <p class="text-xs text-gray-400 mt-1">AI Assessed Risk</p>
                        </div>
                        <div class="bg-orange-500 p-3 rounded-lg">
                            <i data-feather="alert-triangle" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Secure</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-green-900 to-green-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">DNS Health</h3>
                            <p id="securityDnsHealth" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">DNS system status</p>
                        </div>
                        <div class="bg-green-500 p-3 rounded-lg">
                            <i data-feather="globe" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Healthy</span>
                    </div>
                </div>
            </div>

            <!-- TELEGRAM BOT SECTION -->
            <div class="bg-gradient-to-r from-blue-900 to-purple-900 rounded-xl p-6 mb-8 border border-blue-700">
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center space-x-3">
                        <div class="bg-blue-500 p-3 rounded-lg">
                            <i data-feather="send" class="w-6 h-6"></i>
                        </div>
                        <div>
                            <h3 class="text-xl font-bold">üì® Telegram Security Alerts</h3>
                            <p class="text-sm text-gray-300">Get real-time security notifications via Telegram</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <div id="bot-status-indicator" class="w-3 h-3 bg-gray-500 rounded-full"></div>
                        <span id="bot-status-text" class="text-sm text-gray-400">Checking...</span>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Bot Setup -->
                    <div class="bg-gray-800 rounded-lg p-4 border border-gray-700">
                        <h4 class="text-sm font-semibold mb-3 flex items-center">
                            <i data-feather="settings" class="w-4 h-4 mr-2"></i>
                            ‚öô Bot Setup
                        </h4>
                        <div class="space-y-3">
                            <button onclick="checkTelegramStatus()"
                                class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded text-sm font-medium">
                                üîç Check Bot Status
                            </button>
                            <button onclick="autoSetupTelegram()"
                                class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded text-sm font-medium">
                                üöÄ Auto Setup (ngrok + Webhook)
                            </button>
                            <div id="webhook-status" class="text-xs mt-2"></div>
                        </div>
                    </div>

                    <!-- Broadcast Alert -->
                    <div class="bg-gray-800 rounded-lg p-4 border border-gray-700">
                        <h4 class="text-sm font-semibold mb-3 flex items-center">
                            <i data-feather="bell" class="w-4 h-4 mr-2"></i>
                            üîî Broadcast Security Alert
                        </h4>
                        <div class="space-y-3">
                            <textarea id="alertMessage" rows="3" placeholder="Type security alert message..."
                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-green-500 resize-none"></textarea>
                            <div class="flex items-center justify-between text-xs text-gray-400">
                                <span id="subscriber-count">
                                    üë• 0 subscribers
                                </span>
                                <button onclick="broadcastAlert()"
                                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm font-medium">
                                    ‚úà Send Alert
                                </button>
                            </div>
                            <div id="alert-status" class="text-xs"></div>
                        </div>
                    </div>

                    <!-- Bot Statistics -->
                    <div class="bg-gray-800 rounded-lg p-4 border border-gray-700">
                        <h4 class="text-sm font-semibold mb-3 flex items-center">
                            <i data-feather="bar-chart-2" class="w-4 h-4 mr-2"></i>
                            üìä Bot Info
                        </h4>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center py-2 border-b border-gray-700">
                                <span class="text-xs text-gray-400">Bot Name</span>
                                <span id="bot-name" class="text-sm font-bold text-blue-400">--</span>
                            </div>
                            <div class="flex justify-between items-center py-2 border-b border-gray-700">
                                <span class="text-xs text-gray-400">Username</span>
                                <span id="bot-username" class="text-sm font-bold text-green-400">--</span>
                            </div>
                            <div class="flex justify-between items-center py-2">
                                <span class="text-xs text-gray-400">Webhook</span>
                                <span id="webhook-active" class="text-xs text-gray-500">Not Set</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Attack Type Probabilities (ML)</h3>
                    <div class="h-80">
                        <canvas id="mlProbabilitiesChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Port Activity Heatmap</h3>
                    <div class="h-80">
                        <canvas id="portHeatmapChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Connection Failure Analysis</h3>
                    <div class="h-80">
                        <canvas id="connectionFailureChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">DNS Query Length Distribution</h3>
                    <div class="h-80">
                        <canvas id="dnsQueryLengthChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Threat Log -->
            <div class="bg-gray-800 rounded-xl p-6 border border-gray-700 mt-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold">üõ°Ô∏è Threat Incident Log</h3>
                    <span class="text-xs text-gray-400">Session History</span>
                </div>
                <div class="overflow-x-auto max-h-60 overflow-y-auto">
                    <table class="w-full text-sm text-left">
                        <thead class="text-xs text-gray-400 uppercase bg-gray-700 sticky top-0">
                            <tr>
                                <th class="px-4 py-2">Timestamp</th>
                                <th class="px-4 py-2">Threat Type</th>
                                <th class="px-4 py-2">Source IP</th>
                                <th class="px-4 py-2">Confidence</th>
                                <th class="px-4 py-2">Status</th>
                            </tr>
                        </thead>
                        <tbody id="threat-log-body" class="text-gray-300">
                            <tr>
                                <td colspan="5" class="px-4 py-2 text-center text-gray-500">No threats recorded in this
                                    session.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- ==================== PERFORMANCE PAGE ==================== -->
        <div id="performance-page" class="page">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold">Network Performance</h1>
                <button onclick="generatePerformanceReport()"
                    class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm font-medium flex items-center space-x-2">
                    <i data-feather="zap" class="w-4 h-4"></i>
                    <span>Performance Report</span>
                </button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="stat-card bg-gradient-to-br from-blue-900 to-blue-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Bandwidth Utilization</h3>
                            <p id="perfBandwidth" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Current usage</p>
                        </div>
                        <div class="bg-blue-500 p-3 rounded-lg">
                            <i data-feather="radio" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Optimal</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-purple-900 to-purple-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Avg Packet Size</h3>
                            <p id="perfAvgSize" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Bytes per packet</p>
                        </div>
                        <div class="bg-purple-500 p-3 rounded-lg">
                            <i data-feather="package" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Normal</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-green-900 to-green-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">SYN-ACK Ratio</h3>
                            <p id="perfSynAck" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Connection success</p>
                        </div>
                        <div class="bg-green-500 p-3 rounded-lg">
                            <i data-feather="refresh-cw" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Healthy</span>
                    </div>
                </div>

                <div class="stat-card bg-gradient-to-br from-cyan-900 to-cyan-800 rounded-xl p-6 shadow-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-gray-300 text-sm">Inter-Arrival Time</h3>
                            <p id="perfInterArrival" class="text-3xl font-bold mt-2">--</p>
                            <p class="text-xs text-gray-400 mt-1">Packet timing</p>
                        </div>
                        <div class="bg-cyan-500 p-3 rounded-lg">
                            <i data-feather="clock" class="w-6 h-6"></i>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm">
                        <span class="text-green-400">Low latency</span>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Byte Rate Over Time</h3>
                    <div class="h-80">
                        <canvas id="byteRateChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Packet Rate Over Time</h3>
                    <div class="h-80">
                        <canvas id="packetRateChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Unique Destinations Trend</h3>
                    <div class="h-80">
                        <canvas id="uniqueDestChart"></canvas>
                    </div>
                </div>
                <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                    <h3 class="text-lg font-semibold mb-4">Port Scanning Score</h3>
                    <div class="h-80">
                        <canvas id="portScanScoreChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== PACKETS PAGE ==================== -->
        <div id="packets-page" class="page">
            <div class="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
                <h1 class="text-3xl font-bold">Captured Packets</h1>
                <div class="flex gap-4 w-full md:w-auto">
                    <div class="relative w-full md:w-48">
                        <select id="packetProtocolFilter" onchange="filterPacketsTable()"
                            class="appearance-none w-full bg-gray-700 text-white px-4 py-2 pr-8 rounded-lg border border-gray-600 focus:outline-none focus:border-blue-500 text-sm">
                            <option value="All">All Protocols</option>
                            <option value="TCP">TCP</option>
                            <option value="UDP">UDP</option>
                            <option value="ICMP">ICMP</option>
                            <option value="ARP">ARP</option>
                        </select>
                        <div
                            class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                            <i data-feather="chevron-down" class="w-4 h-4"></i>
                        </div>
                    </div>
                    <div class="relative w-full md:w-64">
                        <input type="text" id="packetSearchInput" placeholder="Search IP..."
                            class="pl-10 pr-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:border-blue-500 w-full text-sm"
                            onkeyup="filterPacketsTable()">
                        <div class="absolute left-3 top-2.5 text-gray-400">
                            <i data-feather="search" class="w-4 h-4"></i>
                        </div>
                    </div>
                    <button onclick="exportPackets()"
                        class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm font-medium flex items-center space-x-2 whitespace-nowrap">
                        <i data-feather="save" class="w-4 h-4"></i>
                        <span>Export CSV</span>
                    </button>
                </div>
            </div>

            <div class="bg-gray-800 rounded-xl p-6 border border-gray-700">
                <div class="overflow-x-auto">
                    <table class="w-full text-sm" id="packets-table">
                        <thead>
                            <tr class="border-b border-gray-700">
                                <th class="text-left py-3 px-4 text-gray-400">Timestamp</th>
                                <th class="text-left py-3 px-4 text-gray-400">Source IP</th>
                                <th class="text-left py-3 px-4 text-gray-400">Dest IP</th>
                                <th class="text-left py-3 px-4 text-gray-400">Protocol</th>
                                <th class="text-left py-3 px-4 text-gray-400">Src Port</th>
                                <th class="text-left py-3 px-4 text-gray-400">Dst Port</th>
                                <th class="text-left py-3 px-4 text-gray-400">Length</th>
                                <th class="text-left py-3 px-4 text-gray-400">TCP Flags</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td colspan="8" class="text-center py-8 text-gray-500">Loading packets...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div class="flex justify-center items-center space-x-4 mt-6">
                    <button onclick="loadPackets(currentPacketPage - 1)" id="prev-btn"
                        class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled>
                        ‚Üê Previous
                    </button>
                    <span id="page-info" class="text-gray-400">Page 1</span>
                    <button onclick="loadPackets(currentPacketPage + 1)" id="next-btn"
                        class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg text-sm">
                        Next ‚Üí
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Initialize Feather Icons
        feather.replace();

        // Initialize AOS
        AOS.init({
            duration: 800,
            once: true
        });

        // ==================== CONFIGURATION ====================
        // Use empty string for same-origin requests when served by FastAPI
        const API_BASE_URL = '';
        const TELEGRAM_BOT_URL = 'http://localhost:5000';  // Telegram bot server
        const MAX_BANDWIDTH_BPS = 1000000000; // 1 Gbps Interface Speed (Configurable)
        let chartInstances = {};
        let currentPacketPage = 1;
        let botStatsInterval;

        // ==================== WEBSOCKET FOR REAL-TIME UPDATES ====================
        class DashboardWebSocket {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 3000;
                this.pollingFallback = null;
            }

            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/dashboard`;

                try {
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('‚úÖ WebSocket connected');
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.updateConnectionStatus(true);
                    };

                    this.ws.onmessage = (event) => {
                        this.handleMessage(JSON.parse(event.data));
                    };

                    this.ws.onclose = () => {
                        console.log('‚ùå WebSocket disconnected');
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.isConnected = false;
                    };
                } catch (error) {
                    console.error('Failed to create WebSocket:', error);
                    this.scheduleReconnect();
                }
            }

            handleMessage(data) {
                if (data.type === 'dashboard_update') {
                    this.updateDashboardStats(data.payload);
                } else if (data.type === 'alert') {
                    this.handleSecurityAlert(data.payload);
                } else if (data.type === 'packets') {
                    this.updatePacketTable(data.payload);
                }
            }

            updateDashboardStats(stats) {
                // Update stat cards without flickering
                if (stats.packet_count !== undefined) {
                    document.getElementById('totalPackets').textContent = formatNumber(stats.packet_count);
                }
                if (stats.byte_rate_bps !== undefined) {
                    document.getElementById('avgTraffic').textContent = formatBytes(stats.byte_rate_bps);
                    document.getElementById('peakTraffic').textContent = formatBytes(stats.byte_rate_bps * 1.5);
                }
                if (stats.tcp_count !== undefined) {
                    document.getElementById('activeConnections').textContent = formatNumber(stats.tcp_count);
                }
                if (stats.packet_rate_pps !== undefined) {
                    document.getElementById('packetsSec').textContent = stats.packet_rate_pps.toFixed(0);
                }

                // Update charts in-place (no flicker)
                this.updateChartsInPlace(stats);
                updateTimestamp();
            }

            updateChartsInPlace(stats) {
                // Update traffic volume chart in-place
                if (chartInstances.trafficVolumeChart && stats.byte_rate_bps !== undefined) {
                    const chart = chartInstances.trafficVolumeChart;
                    const now = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });

                    // Add new data point
                    chart.data.labels.push(now);
                    chart.data.datasets[0].data.push(stats.byte_rate_bps / 1000000);

                    // Keep only last 24 points
                    if (chart.data.labels.length > 24) {
                        chart.data.labels.shift();
                        chart.data.datasets[0].data.shift();
                    }

                    chart.update('none'); // 'none' for no animation = instant
                }

                // Update protocol chart if data available
                if (chartInstances.protocolChart && stats.protocol_counts) {
                    const chart = chartInstances.protocolChart;
                    chart.data.datasets[0].data = Object.values(stats.protocol_counts);
                    chart.update('none');
                }
            }

            handleSecurityAlert(alert) {
                // Update security header
                updateSecurityAlert(alert);
                // Add to threat log
                updateThreatLog(alert);
                // Store for reporting
                recentAlerts.unshift(alert);
                if (recentAlerts.length > 100) recentAlerts.pop();
            }

            updatePacketTable(packets) {
                // This would update the packets table dynamically
                // For now, we'll let the pagination handle it
            }

            updateConnectionStatus(connected) {
                const indicator = document.getElementById('db-status-indicator');
                const text = document.getElementById('db-status-text');
                if (connected) {
                    indicator.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse';
                    text.textContent = 'Live';
                    text.className = 'text-xs text-green-400';
                } else {
                    indicator.className = 'w-2 h-2 bg-yellow-500 rounded-full';
                    text.textContent = 'Reconnecting...';
                    text.className = 'text-xs text-yellow-400';
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`Reconnecting in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`);
                    setTimeout(() => this.connect(), this.reconnectDelay);
                } else {
                    console.error('‚ùå Max reconnection attempts reached. Falling back to HTTP polling.');
                    this.startPollingFallback();
                }
            }

            ping() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ type: 'ping' }));
                }
            }

            showToast(message, type = 'info') {
                const colors = {
                    info: 'bg-blue-600',
                    success: 'bg-green-600',
                    warning: 'bg-yellow-600',
                    error: 'bg-red-600'
                };
                const toast = document.createElement('div');
                toast.className = `fixed bottom-4 right-4 p-3 rounded-lg shadow-lg z-50 ${colors[type]} text-white text-sm`;
                toast.textContent = message;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }

            refreshDashboard() {
                const activePage = document.querySelector('.page.active')?.id;
                if (activePage === 'dashboard-page') {
                    loadDashboard();
                }
            }

            refreshSecurityPage() {
                const activePage = document.querySelector('.page.active')?.id;
                if (activePage === 'security-page') {
                    loadSecurity();
                }
            }

            startPollingFallback() {
                if (this.pollingFallback) return;
                console.log('‚ö†Ô∏è Starting HTTP polling fallback');
                this.showToast('WebSocket unavailable. Using polling mode.', 'warning');
                this.pollingFallback = setInterval(() => {
                    const activePage = document.querySelector('.page.active')?.id;
                    if (activePage === 'dashboard-page') initializeDashboard();
                    else if (activePage === 'analytics-page') loadAnalytics();
                    else if (activePage === 'security-page') loadSecurity();
                    else if (activePage === 'performance-page') loadPerformance();
                }, 5000);
            }
        }

        // ==================== TELEGRAM BOT FUNCTIONS ====================
        async function setTelegramWebhook() {
            const url = document.getElementById('webhookUrl').value;
            if (!url) {
                alert('Please enter a webhook URL');
                return;
            }

            const statusEl = document.getElementById('webhook-status');
            statusEl.innerHTML = '<span class="text-blue-400">Setting webhook...</span>';

            try {
                const response = await fetch(`${TELEGRAM_BOT_URL}/api/webhook/set`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ webhook_url: url })
                });
                const data = await response.json();

                if (data.success) {
                    statusEl.innerHTML = '<span class="text-green-400">‚úì Webhook configured!</span>';
                    document.getElementById('bot-status-indicator').className = 'w-3 h-3 bg-green-500 rounded-full animate-pulse';
                    document.getElementById('bot-status-text').innerHTML = '<span class="text-green-400">Bot Active</span>';
                } else {
                    statusEl.innerHTML = '<span class="text-red-400">‚úó Failed to set webhook</span>';
                }
            } catch (error) {
                statusEl.innerHTML = '<span class="text-red-400">Error: ' + error.message + '</span>';
            }
        }

        async function sendSecurityAlert() {
            const message = document.getElementById('alertMessage').value;
            if (!message) {
                alert('Please enter an alert message');
                return;
            }

            const statusEl = document.getElementById('alert-status');
            statusEl.innerHTML = '<span class="text-blue-400">Sending alert...</span>';

            try {
                const response = await fetch(`${TELEGRAM_BOT_URL}/api/broadcast`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: 'üö® SECURITY ALERT üö®\n\n' + message })
                });
                const data = await response.json();

                statusEl.innerHTML = `<span class="text-green-400">‚úì Alert sent to ${data.sent_to} users</span>`;
                document.getElementById('alertMessage').value = '';
                document.getElementById('alerts-sent').textContent = parseInt(document.getElementById('alerts-sent').textContent) + 1;
                document.getElementById('last-alert-time').textContent = new Date().toLocaleTimeString();

                updateBotMessages(`Alert sent to ${data.sent_to} subscribers: "${message}"`);
            } catch (error) {
                statusEl.innerHTML = '<span class="text-red-400">Error: ' + error.message + '</span>';
            }
        }

        async function loadBotStats() {
            try {
                const response = await fetch(`${TELEGRAM_BOT_URL}/api/stats`);
                const data = await response.json();

                document.getElementById('subscriber-count').innerHTML = `üë• ${data.total_users} subscribers`;
                document.getElementById('total-subscribers').textContent = data.total_users;
            } catch (error) {
                console.error('Error loading bot stats:', error);
            }
        }

        async function loadBotMessages() {
            try {
                const response = await fetch(`${TELEGRAM_BOT_URL}/api/messages`);
                const data = await response.json();

                const container = document.getElementById('bot-messages');
                if (data.messages && data.messages.length > 0) {
                    container.innerHTML = data.messages.slice(0, 5).map(msg => `
                        <div class="bg-gray-700 rounded p-2 text-xs">
                            <div class="flex justify-between items-center mb-1">
                                <span class="text-gray-400">Chat ID: ${msg.chat_id}</span>
                                <span class="text-gray-500">${msg.timestamp}</span>
                            </div>
                            <div class="text-white">${msg.text}</div>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<div class="text-center text-gray-500 text-xs py-4">No messages yet</div>';
                }
            } catch (error) {
                console.error('Error loading bot messages:', error);
            }
        }

        function updateBotMessages(message) {
            const container = document.getElementById('bot-messages');
            const newMsg = document.createElement('div');
            newMsg.className = 'bg-gray-700 rounded p-2 text-xs';
            newMsg.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <span class="text-blue-400">System</span>
                    <span class="text-gray-500">${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="text-white">${message}</div>
            `;

            if (container.firstChild && container.firstChild.className === 'text-center text-gray-500 text-xs py-4') {
                container.innerHTML = '';
            }
            container.insertBefore(newMsg, container.firstChild);
        }

        function startBotStatsRefresh() {
            loadBotStats();
            loadBotMessages();
            botStatsInterval = setInterval(() => {
                loadBotStats();
                loadBotMessages();
            }, 3000);
        }

        function stopBotStatsRefresh() {
            if (botStatsInterval) {
                clearInterval(botStatsInterval);
            }
        }

        // ==================== PAGE NAVIGATION ====================
        function showPage(pageName) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });

            document.getElementById(pageName + '-page').classList.add('active');
            event.target.classList.add('active');

            // Stop bot refresh when leaving security page
            stopBotStatsRefresh();

            if (pageName === 'analytics') {
                loadAnalytics();
            } else if (pageName === 'security') {
                loadSecurity();
                startBotStatsRefresh();  // Start bot stats refresh
            } else if (pageName === 'performance') {
                loadPerformance();
            } else if (pageName === 'packets') {
                currentPacketPage = 1;
                loadPackets(1);
            }

            feather.replace();
        }

        function viewIPDetails(ip) {
            showPage('analytics');
            const input = document.getElementById('featureIpInput');
            if (input) {
                input.value = ip;
                loadIPFeatures();
            }
        }

        // ==================== UTILITY FUNCTIONS ====================
        function toTitleCase(str) {
            return str.replace(/_/g, ' ').replace(/\w\S*/g, (txt) => {
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        }

        function formatBytes(bytes) {
            if (!bytes || bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function formatNumber(num) {
            if (!num) return '0';
            return num.toLocaleString();
        }

        function updateTimestamp() {
            const now = new Date();
            const time = now.toLocaleTimeString('en-US', { hour12: false });
            document.getElementById('last-updated').textContent = `Last updated: ${time}`;
        }

        function destroyChart(chartId) {
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
                delete chartInstances[chartId];
            }
        }

        // ==================== DERIVED METRICS ====================
        function calculateNetworkHealth(features) {
            let score = 100;
            const packetLossPenalty = (features.connection_failure_rate || 0) * 50;
            const retransPenalty = (features.tcp_rst_count / Math.max(1, features.tcp_count)) * 20;
            const portScanPenalty = (features.port_scan_score || 0) * 15;
            const arpPenalty = (features.arp_request_rate_pps > 10) ? 10 : 0;

            score -= packetLossPenalty + retransPenalty + portScanPenalty + arpPenalty;
            return Math.max(0, Math.min(100, score));
        }

        function calculateConnectionQuality(features) {
            const successRate = 1 - (features.connection_failure_rate || 0);
            const synAckHealth = Math.min(1, features.syn_ack_ratio || 0);
            const rstRatio = features.tcp_rst_count / Math.max(1, features.tcp_count);
            const rstHealth = Math.max(0, 1 - rstRatio);

            const quality = (successRate * 0.4 + synAckHealth * 0.4 + rstHealth * 0.2) * 100;
            return quality.toFixed(1);
        }

        function calculateProtocolDiversity(features) {
            const total = features.packet_count || 1;
            const protocols = [
                features.tcp_count / total,
                features.udp_count / total,
                features.icmp_count / total,
                (features.other_count || 0) / total
            ].filter(p => p > 0);

            let entropy = 0;
            protocols.forEach(p => {
                if (p > 0) entropy -= p * Math.log2(p);
            });

            return (entropy / 2).toFixed(3);
        }

        function calculateTrafficEfficiency(features) {
            const payloadRatio = (features.avg_packet_size || 0) / 1500;
            const ackOverhead = features.tcp_ack_count / Math.max(1, features.packet_count);
            const protocolEfficiency = 1 - ackOverhead;
            const retransWaste = (features.tcp_rst_count + features.tcp_fin_count) / Math.max(1, features.packet_count);
            const retransEfficiency = 1 - retransWaste;

            const efficiency = (payloadRatio * 0.4 + protocolEfficiency * 0.3 + retransEfficiency * 0.3) * 100;
            return efficiency.toFixed(1);
        }

        function calculateDNSHealth(features) {
            // OPTION 3: Anomaly Detection Score
            // DNS Health = 100 - (tunneling_risk √ó 100)
            // Higher score = healthier DNS, Lower = more suspicious

            const queries = features.dns_query_count || 0;
            const responses = features.dns_response_count || 0;
            const avgQueryLength = features.avg_dns_query_length || 0;
            const packetCount = features.packet_count || 1;

            // Component 1: Normalized query length (long queries = suspicious, max 100 chars)
            const normalizedQueryLength = Math.min(1, avgQueryLength / 100);

            // Component 2: Query burst ratio (many DNS queries relative to total traffic = suspicious)
            const dnsRatio = queries / Math.max(1, packetCount);
            const queryBurstRatio = Math.min(1, dnsRatio * 10);  // 10% DNS traffic = max suspicious

            // Component 3: Low response rate (no responses = DNS tunneling or failure)
            const lowResponseRate = queries > 0 ? 1 - (responses / queries) : 0;

            // Weighted tunneling risk score
            const tunnelingRisk = (
                0.4 * normalizedQueryLength +   // 40% weight: long queries
                0.3 * queryBurstRatio +         // 30% weight: too many DNS queries
                0.3 * Math.max(0, lowResponseRate)  // 30% weight: unanswered queries
            );

            // DNS Health = inverse of risk (100 = safe, 0 = dangerous)
            const health = Math.max(0, Math.min(100, (1 - tunnelingRisk) * 100));

            return health;
        }

        function calculateBandwidthUtilization(features, maxBandwidth = MAX_BANDWIDTH_BPS) {
            const currentBps = (features.byte_rate_bps || 0) * 8;
            const utilization = (currentBps / maxBandwidth) * 100;
            return utilization.toFixed(2);
        }

        function updateTimeRange() {
            const selector = document.getElementById('timeRangeSelector');
            const hours = selector ? selector.value : 24;

            const label = document.getElementById('avgTrafficLabel');
            if (label) {
                if (hours == 0.5) label.textContent = 'Last 30 Minutes';
                else if (hours == 24) label.textContent = 'Last 24 hours';
                else if (hours == 168) label.textContent = 'Last 7 days';
                else if (hours == 720) label.textContent = 'Last 30 days';
            }

            loadTrafficVolumeChart(hours);
            loadProtocolTrendChart();
        }

        // ==================== DASHBOARD PAGE ====================
        async function loadDashboard() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/features`);
                const data = await response.json();

                if (data.error) return;

                document.getElementById('peakTraffic').textContent = formatBytes(data.peak_byte_rate || data.byte_rate_bps || 0);
                document.getElementById('avgTraffic').textContent = formatBytes(data.byte_rate_bps || 0);
                document.getElementById('totalPackets').textContent = formatNumber(data.packet_count || 0);
                document.getElementById('activeConnections').textContent = formatNumber(data.tcp_count || 0);

                const loss = (data.connection_failure_rate || 0) * 100;
                const lossEl = document.getElementById('packetLoss');
                lossEl.textContent = loss.toFixed(1) + '%';
                if (loss > 1.0) lossEl.classList.replace('text-gray-300', 'text-red-500') || lossEl.classList.add('text-red-500');
                else lossEl.classList.remove('text-red-500');

                const latency = (data.inter_arrival_time_mean || 0) * 1000;
                const latEl = document.getElementById('avgLatency');
                latEl.textContent = latency.toFixed(0) + 'ms';
                if (latency > 100) latEl.classList.replace('text-gray-300', 'text-red-500') || latEl.classList.add('text-red-500');
                else latEl.classList.remove('text-red-500');
                document.getElementById('bandwidthUsage').textContent = calculateBandwidthUtilization(data) + '%';
                document.getElementById('tcpTraffic').textContent = Math.round(((data.tcp_count || 0) / Math.max(1, data.packet_count)) * 100) + '%';
                document.getElementById('packetsSec').textContent = (data.packet_rate_pps || 0).toFixed(0);

                updateTimestamp();
            } catch (error) {
                console.error('Error loading dashboard:', error);
            }
        }

        function updateTimestamp() {
            const el = document.getElementById('last-updated');
            if (el) el.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
        }

        async function loadProtocolChart() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/protocols`);
                const data = await response.json();

                if (!data.labels || data.labels.length === 0) return;

                destroyChart('protocolChart');

                const ctx = document.getElementById('protocolChart');
                chartInstances.protocolChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: data.labels,
                        datasets: [{
                            data: data.values,
                            backgroundColor: ['#3b82f6', '#ec4899', '#f59e0b', '#10b981', '#8b5cf6', '#6b7280'],
                            borderWidth: 3,
                            borderColor: '#1f2937'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { padding: 15, font: { size: 11 }, color: '#9ca3af' }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading protocol chart:', error);
            }
        }

        async function loadTrafficVolumeChart(hours = 24) {
            try {
                // USE REAL DATA from /api/traffic-history
                const response = await fetch(`${API_BASE_URL}/api/traffic-history?hours=${hours}`);
                const data = await response.json();

                destroyChart('trafficVolumeChart');

                const labels = data.labels || [];
                const values = (data.byte_rates || []).map(v => v / 1000000);  // Convert to MB/s

                const ctx = document.getElementById('trafficVolumeChart');
                chartInstances.trafficVolumeChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Traffic (MB/s)',
                            data: values,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { color: '#374151' }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading traffic volume chart:', error);
            }
        }

        async function loadProtocolTrendChart() {
            try {
                const selector = document.getElementById('timeRangeSelector');
                const hours = selector ? selector.value : 24;

                const response = await fetch(`${API_BASE_URL}/api/traffic-history?hours=${hours}`);
                const data = await response.json();

                destroyChart('protocolTrendChart');

                const ctx = document.getElementById('protocolTrendChart');
                if (!ctx) return;

                chartInstances.protocolTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.labels || [],
                        datasets: [
                            {
                                label: 'TCP',
                                data: data.tcp_rates || [],
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.3)',
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'UDP',
                                data: data.udp_rates || [],
                                borderColor: '#ec4899',
                                backgroundColor: 'rgba(236, 72, 153, 0.3)',
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'ICMP',
                                data: data.icmp_rates || [],
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.3)',
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'Other',
                                data: data.other_rates || [],
                                borderColor: '#9ca3af',
                                backgroundColor: 'rgba(156, 163, 175, 0.3)',
                                fill: true,
                                tension: 0.4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: { position: 'bottom', labels: { color: '#9ca3af' } },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af' },
                                title: { display: true, text: 'Packets / sec', color: '#6b7280' }
                            },
                            x: {
                                grid: { display: false },
                                ticks: { color: '#9ca3af' }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading protocol trend chart:', error);
            }
        }

        async function loadPacketSizeChart() {
            try {
                // USE REAL DATA from /api/packet-size-distribution
                const response = await fetch(`${API_BASE_URL}/api/packet-size-distribution`);
                const data = await response.json();

                destroyChart('packetSizeChart');

                const ctx = document.getElementById('packetSizeChart');
                chartInstances.packetSizeChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.labels || [],
                        datasets: [{
                            label: 'Packets',
                            data: data.values || [],
                            backgroundColor: '#8b5cf6',
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading packet size chart:', error);
            }
        }

        async function loadTopSources() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/top-sources?limit=5`);
                const data = await response.json();

                const tbody = document.querySelector('#top-sources-table tbody');

                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="3" class="text-center py-4">No data</td></tr>';
                    return;
                }

                tbody.innerHTML = '';
                data.forEach(item => {
                    tbody.innerHTML += `
                        <tr class="border-b border-gray-700 hover:bg-gray-700 transition">
                            <td class="py-3 px-4">
                                <a href="#" onclick="viewIPDetails('${item.ip}')" class="text-blue-400 hover:text-blue-300 hover:underline font-mono">
                                    ${item.ip}
                                </a>
                            </td>
                            <td class="py-3 px-4">${formatNumber(item.packet_count)}</td>
                            <td class="py-3 px-4"><strong>${item.percentage}%</strong></td>
                        </tr>
                    `;
                });
            } catch (error) {
                console.error('Error loading top sources:', error);
            }
        }

        async function loadTopDestinations() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/top-destinations?limit=5`);
                const data = await response.json();

                const tbody = document.querySelector('#top-destinations-table tbody');

                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="3" class="text-center py-4">No data</td></tr>';
                    return;
                }

                tbody.innerHTML = '';
                data.forEach(item => {
                    tbody.innerHTML += `
                        <tr class="border-b border-gray-700 hover:bg-gray-700 transition">
                            <td class="py-3 px-4">
                                <a href="#" onclick="viewIPDetails('${item.ip}')" class="text-blue-400 hover:text-blue-300 hover:underline font-mono">
                                    ${item.ip}
                                </a>
                            </td>
                            <td class="py-3 px-4">${formatNumber(item.packet_count)}</td>
                            <td class="py-3 px-4"><strong>${item.percentage}%</strong></td>
                        </tr>
                    `;
                });
            } catch (error) {
                console.error('Error loading top destinations:', error);
            }
        }

        async function loadTopPorts() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/top-ports?limit=5`);
                const data = await response.json();

                const tbody = document.querySelector('#top-ports-table tbody');

                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="3" class="text-center py-4">No data</td></tr>';
                    return;
                }

                tbody.innerHTML = '';
                data.forEach(item => {
                    tbody.innerHTML += `
                        <tr class="border-b border-gray-700 hover:bg-gray-700">
                            <td class="py-3 px-4"><strong>${item.port}</strong></td>
                            <td class="py-3 px-4">${item.service}</td>
                            <td class="py-3 px-4"><strong>${item.percentage}%</strong></td>
                        </tr>
                    `;
                });
            } catch (error) {
                console.error('Error loading top ports:', error);
            }
        }

        // ==================== ANALYTICS PAGE ====================
        async function loadAnalytics() {
            try {
                // USE EXTENDED FEATURES for all derived metrics
                const response = await fetch(`${API_BASE_URL}/api/features-extended`);
                const features = await response.json();

                const health = calculateNetworkHealth(features);
                const quality = calculateConnectionQuality(features);
                const diversity = calculateProtocolDiversity(features);
                const efficiency = calculateTrafficEfficiency(features);

                document.getElementById('analyticsHealth').textContent = health.toFixed(0);
                document.getElementById('analyticsQuality').textContent = quality;
                document.getElementById('analyticsDiversity').textContent = diversity;
                document.getElementById('analyticsEfficiency').textContent = efficiency + '%';

                await loadHealthGaugeChart(health);
                await loadConnectionSuccessChart(features);
                await loadTCPFlagsChart(features);
                await loadDNSAnalysisChart(features);
                await loadFeatures();

            } catch (error) {
                console.error('Error loading analytics:', error);
            }
        }

        async function loadHealthGaugeChart(health) {
            try {
                destroyChart('healthGaugeChart');

                const ctx = document.getElementById('healthGaugeChart');
                chartInstances.healthGaugeChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        datasets: [{
                            data: [health, 100 - health],
                            backgroundColor: [
                                health > 80 ? '#10b981' : health > 60 ? '#3b82f6' : health > 40 ? '#f59e0b' : '#ef4444',
                                '#374151'
                            ],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        circumference: 270,
                        rotation: 225,
                        cutout: '75%',
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    },
                    plugins: [{
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            ctx.save();
                            const centerX = chart.width / 2;
                            const centerY = chart.height / 2;
                            ctx.font = '48px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.textAlign = 'center';
                            ctx.fillText(health.toFixed(0), centerX, centerY);
                            ctx.font = '16px Arial';
                            ctx.fillStyle = '#9ca3af';
                            ctx.fillText('Health Score', centerX, centerY + 30);
                            ctx.restore();
                        }
                    }]
                });
            } catch (error) {
                console.error('Error loading health gauge:', error);
            }
        }

        async function loadConnectionSuccessChart(features) {
            try {
                const successRate = (1 - (features.connection_failure_rate || 0)) * 100;

                destroyChart('connectionSuccessChart');

                const ctx = document.getElementById('connectionSuccessChart');
                chartInstances.connectionSuccessChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        datasets: [{
                            data: [successRate, 100 - successRate],
                            backgroundColor: [
                                successRate > 80 ? '#10b981' : successRate > 50 ? '#f59e0b' : '#ef4444',
                                '#374151'
                            ],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        circumference: 180,
                        rotation: 270,
                        cutout: '80%',
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    },
                    plugins: [{
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            ctx.save();
                            const centerX = chart.width / 2;
                            const centerY = chart.height / 2;
                            ctx.font = '36px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.textAlign = 'center';
                            ctx.fillText(successRate.toFixed(1) + '%', centerX, centerY);
                            ctx.font = '14px Arial';
                            ctx.fillStyle = '#9ca3af';
                            ctx.fillText('Success Rate', centerX, centerY + 25);
                            ctx.restore();
                        }
                    }]
                });
            } catch (error) {
                console.error('Error loading connection success chart:', error);
            }
        }

        async function loadTCPFlagsChart(features) {
            try {
                const tcpData = features;

                destroyChart('tcpFlagsChart');

                const ctx = document.getElementById('tcpFlagsChart');
                chartInstances.tcpFlagsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['SYN', 'ACK', 'FIN', 'RST', 'PSH'],
                        datasets: [{
                            label: 'Count',
                            data: [
                                tcpData.tcp_syn_count || 0,
                                tcpData.tcp_ack_count || 0,
                                tcpData.tcp_fin_count || 0,
                                tcpData.tcp_rst_count || 0,
                                tcpData.tcp_psh_count || 0
                            ],
                            backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'],
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: '#374151' },
                                ticks: { color: '#9ca3af', callback: function (value) { return formatNumber(value); } }
                            },
                            x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading TCP flags chart:', error);
            }
        }

        async function loadDNSAnalysisChart(features) {
            try {
                const dnsData = features;

                destroyChart('dnsAnalysisChart');

                const ctx = document.getElementById('dnsAnalysisChart');
                chartInstances.dnsAnalysisChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Queries', 'Responses', 'Unique Domains', 'Avg Length'],
                        datasets: [{
                            label: 'DNS Metrics',
                            data: [
                                dnsData.dns_query_count || 0,
                                dnsData.dns_response_count || 0,
                                dnsData.dns_unique_domains || 0,
                                (dnsData.avg_dns_query_length || 0) * 10
                            ],
                            backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6'],
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading DNS analysis chart:', error);
            }
        }

        async function loadIPFeatures() {
            const ipInput = document.getElementById('featureIpInput');
            const ip = ipInput.value.trim();
            if (!ip) {
                alert('Please enter an IP address');
                return;
            }
            await loadFeatures(ip);
        }

        async function loadFeatures(targetIp = null) {
            try {
                let url = `${API_BASE_URL}/api/features`;
                if (targetIp) {
                    url = `${API_BASE_URL}/api/features/ip/${targetIp}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    document.getElementById('features-container').innerHTML =
                        '<p class="text-center text-gray-500 py-8">No data available</p>';
                    return;
                }

                const categories = {
                    'Packet Statistics': ['src_ip', 'packet_count', 'packet_rate_pps', 'byte_count', 'byte_rate_bps', 'avg_packet_size', 'packet_size_variance', 'min_packet_size', 'max_packet_size'],
                    'Protocol Distribution': ['tcp_count', 'udp_count', 'icmp_count', 'arp_count'],
                    'Port Activity': ['unique_dst_ips', 'unique_dst_ports', 'tcp_ports_hit', 'udp_ports_hit', 'remote_conn_port_hits', 'udp_dest_port_count'],
                    'TCP & DoS Analysis': ['tcp_syn_count', 'tcp_ack_count', 'syn_rate_pps', 'syn_ack_rate_pps', 'syn_to_synack_ratio', 'half_open_count', 'syn_only_ratio', 'icmp_rate_pps', 'udp_rate_pps'],
                    'Bruteforce Detection': ['ssh_connection_attempts', 'ftp_connection_attempts', 'http_login_attempts', 'login_request_rate', 'failed_login_count', 'auth_attempts_per_min'],
                    'ARP & Spoofing': ['arp_request_count', 'arp_reply_count', 'gratuitous_arp_count', 'arp_binding_flap_count', 'arp_reply_without_request_count', 'unique_macs_per_ip_max', 'avg_macs_per_ip', 'duplicate_mac_ips', 'mac_ip_ratio', 'suspicious_mac_changes'],
                    'DNS Analysis': ['dns_query_count', 'query_rate_qps', 'unique_qnames_count', 'avg_subdomain_entropy', 'pct_high_entropy_queries', 'txt_record_count', 'avg_answer_size', 'distinct_record_types', 'avg_query_interval_ms', 'avg_subdomain_length', 'max_subdomain_length', 'avg_label_count', 'dns_to_udp_ratio', 'udp_port_53_count'],
                    'Slowloris & Scanning': ['open_conn_count', 'avg_conn_duration', 'bytes_per_conn', 'partial_http_count', 'request_completion_ratio', 'sequential_port_count', 'scan_rate_pps', 'distinct_targets_count']
                };

                let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';

                for (const [category, features] of Object.entries(categories)) {
                    html += `<div class="col-span-full"><h4 class="text-lg font-semibold text-blue-400 mt-4 mb-2 border-b border-gray-700 pb-2">${category}</h4></div>`;

                    features.forEach(key => {
                        if (data.hasOwnProperty(key)) {
                            let value = data[key];
                            if (typeof value === 'number') {
                                if (key.includes('rate') || key.includes('ratio') || key.includes('score')) {
                                    value = value.toFixed(2);
                                } else {
                                    value = formatNumber(value);
                                }
                            }

                            html += `
                                <div class="bg-gray-700 rounded-lg p-4 border border-gray-600 border-l-4 border-l-blue-500">
                                    <div class="text-xs text-gray-400 font-semibold mb-1">${toTitleCase(key)}</div>
                                    <div class="text-xl font-bold text-white">${value}</div>
                                </div>
                            `;
                        }
                    });
                }

                html += '</div>';
                document.getElementById('features-container').innerHTML = html;

            } catch (error) {
                console.error('Error loading features:', error);
            }
        }

        // ==================== SECURITY PAGE ====================
        async function loadSecurity() {
            try {
                const mlResponse = await fetch(`${API_BASE_URL}/api/ml/predict`);
                const mlData = await mlResponse.json();

                document.getElementById('mlAttackType').textContent = mlData.attack_type || 'Unknown';
                document.getElementById('mlConfidence').textContent = (mlData.confidence || 0).toFixed(1) + '%';
                document.getElementById('mlThreatLevel').textContent = mlData.threat_level || 'NONE';

                const alertCard = document.getElementById('security-alert');
                const statusEl = document.getElementById('security-status');
                const messageEl = document.getElementById('security-message');

                if (mlData.threat_level && mlData.threat_level !== 'NONE' && mlData.threat_level !== 'LOW') {
                    alertCard.className = mlData.threat_level === 'CRITICAL' ?
                        'bg-gradient-to-r from-red-900 to-red-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-red-700' :
                        'bg-gradient-to-r from-orange-900 to-orange-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-orange-700';

                    // Fix: Re-create the icon element
                    const iconContainer = alertCard.querySelector('.alert-icon');
                    iconContainer.innerHTML = '<i data-feather="alert-triangle" class="w-8 h-8"></i>';

                    statusEl.textContent = 'Security Alert';
                    messageEl.textContent = `${mlData.attack_type} detected with ${mlData.confidence.toFixed(1)}% confidence. Immediate action may be required.`;
                    feather.replace();
                } else {
                    alertCard.className = 'bg-gradient-to-r from-green-900 to-green-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-green-700';

                    // Fix: Re-create the icon element
                    const iconContainer = alertCard.querySelector('.alert-icon');
                    iconContainer.innerHTML = '<i data-feather="check-circle" class="w-8 h-8"></i>';

                    statusEl.textContent = 'All Clear';
                    messageEl.textContent = 'No threats detected. Network operating normally.';
                    feather.replace();
                }

                const featResponse = await fetch(`${API_BASE_URL}/api/features`);
                const features = await featResponse.json();

                const dnsHealth = calculateDNSHealth(features);
                document.getElementById('securityDnsHealth').textContent = dnsHealth.toFixed(0);

                await loadMLProbabilitiesChart(mlData);
                await loadPortHeatmap();
                await loadConnectionFailureChart(features);

                await loadDNSQueryLengthChart(features);
                await loadThreatLog();

            } catch (error) {
                console.error('Error loading security:', error);
            }
        }

        async function loadMLProbabilitiesChart(mlData) {
            try {
                destroyChart('mlProbabilitiesChart');

                const probabilities = {
                    'Normal': mlData.attack_type === 'Normal' ? mlData.confidence : 0,
                    'DDoS': mlData.attack_type === 'DDoS' ? mlData.confidence : 0,
                    'Port Scan': mlData.attack_type === 'Port Scan' ? mlData.confidence : 0,
                    'DNS Tunnel': mlData.attack_type === 'DNS Tunnel' ? mlData.confidence : 0,
                    'Brute Force': mlData.attack_type === 'Brute Force' ? mlData.confidence : 0
                };

                const ctx = document.getElementById('mlProbabilitiesChart');
                chartInstances.mlProbabilitiesChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Object.keys(probabilities),
                        datasets: [{
                            label: 'Probability %',
                            data: Object.values(probabilities),
                            backgroundColor: ['#10b981', '#ef4444', '#f59e0b', '#8b5cf6', '#ec4899'],
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, max: 100, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading ML probabilities chart:', error);
            }
        }

        async function loadPortHeatmap() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/top-ports?limit=10`);
                const data = await response.json();

                destroyChart('portHeatmapChart');

                // Create a proper heatmap-style visualization using a bubble chart
                // Each port gets a cell with color intensity based on packet count
                const maxPackets = Math.max(...data.map(p => p.packet_count || 1));

                // Generate heatmap-style data with intensity colors
                const datasets = data.map((p, idx) => {
                    const intensity = (p.packet_count || 0) / maxPackets;
                    const r = Math.round(239 * intensity + 16 * (1 - intensity));  // Red for high, green for low
                    const g = Math.round(68 * intensity + 185 * (1 - intensity));
                    const b = Math.round(68 * intensity + 129 * (1 - intensity));

                    return {
                        label: `Port ${p.port}`,
                        data: [{ x: 0, y: idx, v: p.packet_count }],
                        backgroundColor: `rgba(${r}, ${g}, ${b}, 0.8)`,
                        borderColor: `rgba(${r}, ${g}, ${b}, 1)`,
                        borderWidth: 2,
                        pointRadius: 20,
                        pointStyle: 'rectRounded'
                    };
                });

                const ctx = document.getElementById('portHeatmapChart');
                chartInstances.portHeatmapChart = new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: 'Port Activity',
                            data: data.map((p, idx) => ({
                                x: 0,
                                y: idx,
                                r: Math.min(40, Math.max(10, (p.packet_count / maxPackets) * 40))
                            })),
                            backgroundColor: data.map(p => {
                                const intensity = (p.packet_count || 0) / maxPackets;
                                // Red for critical ports, green for normal
                                if ([22, 3389, 23].includes(p.port)) return `rgba(239, 68, 68, ${0.4 + intensity * 0.6})`;
                                if ([80, 443].includes(p.port)) return `rgba(16, 185, 129, ${0.4 + intensity * 0.6})`;
                                if (p.port === 53) return `rgba(59, 130, 246, ${0.4 + intensity * 0.6})`;
                                return `rgba(139, 92, 246, ${0.4 + intensity * 0.6})`;
                            }),
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        const p = data[ctx.dataIndex];
                                        return `Port ${p.port} (${p.service}): ${p.packet_count} packets`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                type: 'category',
                                labels: data.map(p => `${p.port} (${p.service})`),
                                grid: { display: false },
                                ticks: { color: '#9ca3af', font: { size: 11 } }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading port heatmap:', error);
            }
        }

        async function loadConnectionFailureChart(features) {
            try {
                destroyChart('connectionFailureChart');

                const successRate = (1 - (features.connection_failure_rate || 0)) * 100;
                const failureRate = (features.connection_failure_rate || 0) * 100;

                const ctx = document.getElementById('connectionFailureChart');
                chartInstances.connectionFailureChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Success', 'Failed'],
                        datasets: [{
                            data: [successRate, failureRate],
                            backgroundColor: ['#10b981', '#ef4444'],
                            borderWidth: 3,
                            borderColor: '#1f2937'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { color: '#9ca3af', padding: 15 }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading connection failure chart:', error);
            }
        }

        async function loadDNSQueryLengthChart(features) {
            try {
                // USE REAL DATA from /api/dns-stats
                const response = await fetch(`${API_BASE_URL}/api/dns-stats`);
                const dnsData = await response.json();
                const dist = dnsData.length_distribution || {};

                destroyChart('dnsQueryLengthChart');

                const avg = dnsData.avg_dns_query_length || 0;
                const chartData = {
                    labels: ['<10', '10-20', '20-40', '40-60', '60-100', '>100'],
                    datasets: [{
                        label: 'Query Count',
                        data: [
                            dist['<10'] || 0,
                            dist['10-20'] || 0,
                            dist['20-40'] || 0,
                            dist['40-60'] || 0,
                            dist['60-100'] || 0,
                            dist['>100'] || 0
                        ],
                        backgroundColor: avg > 50 ? '#ef4444' : '#10b981',
                        borderRadius: 8
                    }]
                };

                const ctx = document.getElementById('dnsQueryLengthChart');
                chartInstances.dnsQueryLengthChart = new Chart(ctx, {
                    type: 'bar',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading DNS query length chart:', error);
            }
        }

        async function loadThreatLog() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/alerts?limit=50`);
                const data = await response.json();
                const tbody = document.getElementById('threat-log-body');

                if (!data.alerts || data.alerts.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5" class="px-4 py-2 text-center text-gray-500">No threats recorded in this session.</td></tr>';
                    return;
                }

                tbody.innerHTML = ''; // Clear fallback message

                data.alerts.forEach(alert => {
                    const color = alert.severity === 'CRITICAL' ? 'text-red-500' :
                        alert.severity === 'HIGH' ? 'text-orange-500' :
                            alert.severity === 'MEDIUM' ? 'text-yellow-500' : 'text-blue-500';

                    const row = `
                        <tr class="border-b border-gray-700 hover:bg-gray-700">
                            <td class="px-4 py-2 text-gray-400">${new Date(alert.detected_at).toLocaleTimeString()}</td>
                            <td class="px-4 py-2 font-bold ${color}">${alert.attack_type}</td>
                            <td class="px-4 py-2 text-gray-300 font-mono">${alert.src_ip}</td>
                            <td class="px-4 py-2 text-gray-400">${alert.confidence.toFixed(1)}%</td>
                            <td class="px-4 py-2">
                                <span class="px-2 py-1 rounded text-xs font-semibold ${alert.resolved ? 'bg-green-900 text-green-300' : 'bg-red-900 text-red-300'}">
                                    ${alert.resolved ? 'RESOLVED' : 'ACTIVE'}
                                </span>
                            </td>
                        </tr>
                    `;
                    tbody.innerHTML += row;
                });
            } catch (error) {
                console.error('Error loading threat log:', error);
            }
        }


        // ==================== PERFORMANCE PAGE ====================
        async function loadPerformance() {
            try {
                // USE EXTENDED FEATURES for syn_ack_ratio, port_scan_score, inter_arrival_time
                const response = await fetch(`${API_BASE_URL}/api/features-extended`);
                const features = await response.json();

                document.getElementById('perfBandwidth').textContent = calculateBandwidthUtilization(features) + '%';
                document.getElementById('perfAvgSize').textContent = (features.avg_packet_size || 0).toFixed(0) + ' B';
                document.getElementById('perfSynAck').textContent = (features.syn_ack_ratio || 0).toFixed(2);
                document.getElementById('perfInterArrival').textContent = ((features.inter_arrival_time_mean || 0) * 1000).toFixed(2) + ' ms';

                await loadByteRateChart(features);
                await loadPacketRateChart(features);
                await loadUniqueDestChart(features);
                await loadPortScanScoreChart(features);

            } catch (error) {
                console.error('Error loading performance:', error);
            }
        }

        async function loadByteRateChart(features) {
            try {
                // USE REAL DATA from /api/traffic-history
                const response = await fetch(`${API_BASE_URL}/api/traffic-history?hours=12`);
                const data = await response.json();

                destroyChart('byteRateChart');

                const labels = data.labels || [];
                const values = (data.byte_rates || []).map(v => v / 1000000);  // Convert to MB/s

                const ctx = document.getElementById('byteRateChart');
                chartInstances.byteRateChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Byte Rate (MB/s)',
                            data: values,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { labels: { color: '#9ca3af' } } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { color: '#374151' }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading byte rate chart:', error);
            }
        }

        async function loadPacketRateChart(features) {
            try {
                // USE REAL DATA from /api/traffic-history
                const response = await fetch(`${API_BASE_URL}/api/traffic-history?hours=12`);
                const data = await response.json();

                destroyChart('packetRateChart');

                const labels = data.labels || [];
                const values = data.packet_rates || [];

                const ctx = document.getElementById('packetRateChart');
                chartInstances.packetRateChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Packet Rate (pps)',
                            data: values,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { labels: { color: '#9ca3af' } } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { color: '#374151' }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading packet rate chart:', error);
            }
        }

        async function loadUniqueDestChart(features) {
            try {
                destroyChart('uniqueDestChart');

                const ctx = document.getElementById('uniqueDestChart');
                chartInstances.uniqueDestChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Unique IPs', 'Unique Ports'],
                        datasets: [{
                            label: 'Count',
                            data: [features.unique_dst_ips || 0, features.unique_dst_ports || 0],
                            backgroundColor: ['#8b5cf6', '#ec4899'],
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#374151' }, ticks: { color: '#9ca3af' } },
                            x: { grid: { display: false }, ticks: { color: '#9ca3af' } }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading unique dest chart:', error);
            }
        }

        async function loadPortScanScoreChart(features) {
            try {
                destroyChart('portScanScoreChart');

                const score = (features.port_scan_score || 0) * 100;

                const ctx = document.getElementById('portScanScoreChart');
                chartInstances.portScanScoreChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        datasets: [{
                            data: [score, 100 - score],
                            backgroundColor: [
                                score > 70 ? '#ef4444' : score > 40 ? '#f59e0b' : '#10b981',
                                '#374151'
                            ],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        circumference: 270,
                        rotation: 225,
                        cutout: '75%',
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    },
                    plugins: [{
                        afterDraw: (chart) => {
                            const ctx = chart.ctx;
                            ctx.save();
                            const centerX = chart.width / 2;
                            const centerY = chart.height / 2;
                            ctx.font = '48px Arial';
                            ctx.fillStyle = '#fff';
                            ctx.textAlign = 'center';
                            ctx.fillText(score.toFixed(0), centerX, centerY);
                            ctx.font = '16px Arial';
                            ctx.fillStyle = '#9ca3af';
                            ctx.fillText('Scan Score', centerX, centerY + 30);
                            ctx.restore();
                        }
                    }]
                });
            } catch (error) {
                console.error('Error loading port scan score chart:', error);
            }
        }

        // ==================== PACKETS PAGE ====================
        // ==================== PACKETS PAGE ====================
        let searchTimeout;

        function filterPacketsTable() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentPacketPage = 1; // Reset to first page
                loadPackets(1);
            }, 300); // 300ms debounce
        }

        async function loadPackets(page) {
            try {
                const protocol = document.getElementById('packetProtocolFilter') ? document.getElementById('packetProtocolFilter').value : 'All';
                const search = document.getElementById('packetSearchInput') ? document.getElementById('packetSearchInput').value : '';

                let url = `${API_BASE_URL}/api/packets?page=${page}&limit=20`;
                if (protocol && protocol !== 'All') url += `&protocol=${protocol}`;
                if (search) url += `&search=${encodeURIComponent(search)}`;

                const response = await fetch(url);
                const data = await response.json();

                const tbody = document.querySelector('#packets-table tbody');

                if (!data.packets || data.packets.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" class="text-center py-8 text-gray-400">No packets found matching criteria</td></tr>';

                    // Update Paging info even if empty
                    document.getElementById('page-info').textContent = `Page 1 of 1`;
                    document.getElementById('prev-btn').disabled = true;
                    document.getElementById('next-btn').disabled = true;
                    return;
                }

                currentPacketPage = page;
                tbody.innerHTML = '';

                data.packets.forEach(pkt => {
                    let protocolBadge = '';
                    if (pkt.protocol === 'TCP') protocolBadge = '<span class="bg-blue-500 text-white px-2 py-1 rounded text-xs">TCP</span>';
                    else if (pkt.protocol === 'UDP') protocolBadge = '<span class="bg-pink-500 text-white px-2 py-1 rounded text-xs">UDP</span>';
                    else if (pkt.protocol === 'ICMP') protocolBadge = '<span class="bg-yellow-500 text-white px-2 py-1 rounded text-xs">ICMP</span>';
                    else if (pkt.protocol === 'ARP') protocolBadge = '<span class="bg-green-500 text-white px-2 py-1 rounded text-xs">ARP</span>';
                    else protocolBadge = `<span class="bg-gray-500 text-white px-2 py-1 rounded text-xs">${pkt.protocol}</span>`;

                    tbody.innerHTML += `
                        <tr class="border-b border-gray-700 hover:bg-gray-700">
                            <td class="py-3 px-4">${pkt.timestamp}</td>
                            <td class="py-3 px-4 font-mono text-gray-300">${pkt.src_ip}</td>
                            <td class="py-3 px-4 font-mono text-gray-300">${pkt.dst_ip}</td>
                            <td class="py-3 px-4">${protocolBadge}</td>
                            <td class="py-3 px-4">${pkt.src_port || '--'}</td>
                            <td class="py-3 px-4">${pkt.dst_port || pkt.port || '--'}</td>
                            <td class="py-3 px-4">${pkt.length}</td>
                            <td class="py-3 px-4 font-mono text-xs">${pkt.flags || '--'}</td>
                        </tr>
                    `;
                });

                const totalPages = Math.ceil(data.total / 20) || 1;
                document.getElementById('page-info').textContent = `Page ${page} of ${totalPages}`;
                document.getElementById('prev-btn').disabled = page <= 1;
                document.getElementById('next-btn').disabled = page >= totalPages;

            } catch (error) {
                console.error('Error loading packets:', error);
            }
        }

        // NOTE: DashboardWebSocket class is defined earlier in the file (around line 891)
        // Removed duplicate definition that was here to fix SyntaxError

        // Helper function for number formatting
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        // ==================== ENHANCEMENTS ====================

        // ==================== ENHANCEMENTS ====================
        // ==================== LEGACY CODE REMOVED ====================


        async function exportDashboardData() {
            try {
                // Fetch all necessary data in parallel
                const [featRes, srcRes, dstRes, portRes] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/features`),
                    fetch(`${API_BASE_URL}/api/top-sources?limit=10`),
                    fetch(`${API_BASE_URL}/api/top-destinations?limit=10`),
                    fetch(`${API_BASE_URL}/api/top-ports?limit=10`)
                ]);

                const features = await featRes.json();
                const topSrc = await srcRes.json();
                const topDst = await dstRes.json();
                const topPorts = await portRes.json();

                if (features.error) { alert(`Error: ${features.error}`); return; }

                const start = features.window_start || new Date().toISOString();
                const end = features.window_end || new Date().toISOString();

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Network Executive Summary\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;
                csv += `\n[SECTION] 1. TRAFFIC OVERVIEW\n`;
                csv += "Metric,Value\n";
                csv += `Byte Rate,${(features.byte_rate_bps || 0) / 1000} KBps\n`;
                csv += `Packet Rate,${(features.packet_rate_pps || 0).toFixed(1)} pps\n`;
                csv += `Total Packets,${features.packet_count || 0}\n`;
                csv += `Active Connections (TCP),${features.tcp_count || 0}\n`;
                csv += `Unique Source IPs,${features.unique_src_ips || 0}\n`;

                csv += `\n[SECTION] 2. TOP SOURCE IPs\n`;
                csv += "Rank,IP Address,Packets,Percentage\n";
                topSrc.forEach((item, i) => {
                    csv += `${i + 1},${item.ip},${item.packet_count},${item.percentage}%\n`;
                });

                csv += `\n[SECTION] 3. TOP DESTINATION IPs\n`;
                csv += "Rank,IP Address,Packets,Percentage\n";
                topDst.forEach((item, i) => {
                    csv += `${i + 1},${item.ip},${item.packet_count},${item.percentage}%\n`;
                });

                csv += `\n[SECTION] 4. TOP PROTOCOL PORTS\n`;
                csv += "Rank,Port,Service,Packets,Percentage\n";
                topPorts.forEach((item, i) => {
                    csv += `${i + 1},${item.port},${item.service},${item.packet_count},${item.percentage}%\n`;
                });

                downloadFile(csv, `executive_summary_${Date.now()}.csv`, 'text/csv');
            } catch (error) {
                alert('Export failed: ' + error.message);
            }
        }

        async function exportExecutiveSummary() {
            try {
                // Fetch all necessary data
                const [featRes, srcRes, dstRes, portRes, protoRes] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/features`),
                    fetch(`${API_BASE_URL}/api/top-sources?limit=10`),
                    fetch(`${API_BASE_URL}/api/top-destinations?limit=10`),
                    fetch(`${API_BASE_URL}/api/top-ports?limit=10`),
                    fetch(`${API_BASE_URL}/api/protocols`)
                ]);

                const features = await featRes.json();
                const topSrc = await srcRes.json();
                const topDst = await dstRes.json();
                const topPorts = await portRes.json();
                const protocols = await protoRes.json();

                if (features.error) { alert(`Error: ${features.error}`); return; }

                const start = features.window_start || new Date().toISOString();
                const end = features.window_end || new Date().toISOString();

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Executive Summary\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;

                // 1. TOP SOURCE IPs (Priority)
                csv += `\n[SECTION] 1. TOP SOURCE IPs\n`;
                csv += "Rank,IP Address,Packets,Percentage\n";
                topSrc.forEach((item, i) => {
                    csv += `${i + 1},${item.ip},${item.packet_count},${item.percentage}%\n`;
                });

                // 2. TOP DESTINATION IPs
                csv += `\n[SECTION] 2. TOP DESTINATION IPs\n`;
                csv += "Rank,IP Address,Packets,Percentage\n";
                topDst.forEach((item, i) => {
                    csv += `${i + 1},${item.ip},${item.packet_count},${item.percentage}%\n`;
                });

                // 3. TOP SERVICES (PORTS)
                csv += `\n[SECTION] 3. TOP SERVICES (PORTS)\n`;
                csv += "Rank,Port,Service,Packets,Percentage\n";
                topPorts.forEach((item, i) => {
                    csv += `${i + 1},${item.port},${item.service},${item.packet_count},${item.percentage}%\n`;
                });

                // 4. PROTOCOL DISTRIBUTION (Transport)
                csv += `\n[SECTION] 4. TRANSPORT PROTOCOLS\n`;
                csv += "Protocol,Count\n";
                if (protocols.labels) {
                    protocols.labels.forEach((label, i) => {
                        csv += `${label},${protocols.values[i]}\n`;
                    });
                }

                // 5. NETWORK HEALTH (Aggregated Features - Last)
                csv += `\n[SECTION] 5. NETWORK HEALTH OVERVIEW\n`;
                csv += "Metric,Value\n";
                csv += `Byte Rate,${(features.byte_rate_bps || 0) / 1000} KBps\n`;
                csv += `Packet Rate,${(features.packet_rate_pps || 0).toFixed(1)} pps\n`;
                csv += `Total Packets,${features.packet_count || 0}\n`;
                csv += `Active Connections,${features.tcp_count || 0}\n`;
                csv += `Unique IPs,${features.unique_src_ips || 0}\n`;

                downloadFile(csv, `executive_summary_${Date.now()}.csv`, 'text/csv');
            } catch (error) {
                alert('Export failed: ' + error.message);
            }
        }

        // Helper to download files
        function downloadFile(content, fileName, mimeType) {
            const a = document.createElement('a');
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            a.setAttribute('href', url);
            a.setAttribute('download', fileName);
            a.click();
            URL.revokeObjectURL(url);
        }

        async function generateAnalyticsReport() {
            await exportExecutiveSummary();
        }

        async function generateSecurityReport() {
            try {
                const [mlRes, featRes, srcRes, portRes] = await Promise.all([
                    fetch(`${API_BASE_URL}/api/ml/predict`),
                    fetch(`${API_BASE_URL}/api/features`),
                    fetch(`${API_BASE_URL}/api/top-sources?limit=10`),
                    fetch(`${API_BASE_URL}/api/top-ports?limit=10`)
                ]);

                const mlData = await mlRes.json();
                const features = await featRes.json();
                const topSrc = await srcRes.json();
                const topPorts = await portRes.json();

                if (features.error) { alert(`Error: ${features.error}`); return; }

                const start = features.window_start || new Date().toISOString();
                const end = features.window_end || new Date().toISOString();

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Security Assessment Report\n`;
                csv += `# Generated At: ${new Date().toLocaleString()}\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;

                csv += `\n[SECTION] 1. THREAT DETECTION STATUS\n`;
                csv += "Metric,Value\n";
                csv += `Current Threat Level,${mlData.threat_level || 'UNKNOWN'}\n`;
                csv += `Detected Attack Type,${mlData.attack_type || 'None'}\n`;
                csv += `ML Confidence,${(mlData.confidence || 0).toFixed(1)}%\n`;
                csv += `DNS Health Score,${calculateDNSHealth(features).toFixed(1)}/100\n`;

                csv += `\n[SECTION] 2. ANOMALY INDICATORS\n`;
                csv += "Indicator,Value,Threshold\n";
                csv += `Connection Failure Rate,${((features.connection_failure_rate || 0) * 100).toFixed(1)}%,>20% is suspicious\n`;
                csv += `Port Scan Score,${(features.port_scan_score || 0).toFixed(1)},>0.6 is suspicious\n`;
                csv += `ARP Spoofing Risk,${features.arp_reply_without_request_count > 0 ? 'DETECTED' : 'None'},>0 packets\n`;
                csv += `DNS Tunneling Risk,${(100 - calculateDNSHealth(features)).toFixed(1)}%,>50% is suspicious\n`;

                csv += `\n[SECTION] 3. SUSPICIOUS TRAFFIC SOURCES (Top Talkers)\n`;
                csv += "Rank,IP Address,Packets,Percentage\n";
                topSrc.forEach((item, i) => {
                    csv += `${i + 1},${item.ip},${item.packet_count},${item.percentage}%\n`;
                });

                csv += `\n[SECTION] 4. TOP TARGETED SERVICES (Ports)\n`;
                csv += "Rank,Port,Service,Packets,Percentage\n";
                topPorts.forEach((item, i) => {
                    csv += `${i + 1},${item.port},${item.service},${item.packet_count},${item.percentage}%\n`;
                });

                downloadFile(csv, `security_report_${Date.now()}.csv`, 'text/csv');
            } catch (error) {
                alert('Security Export failed: ' + error.message);
                console.error(error);
            }
        }

        async function generatePerformanceReport() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/features-extended`);
                const features = await response.json();

                if (features.error) {
                    // Fallback to basic features if extended fails
                    const basicRes = await fetch(`${API_BASE_URL}/api/features`);
                    const basicFeat = await basicRes.json();
                    if (basicFeat.error) { alert('Export failed: No data available'); return; }
                    Object.assign(features, basicFeat);
                }

                const start = features.window_start || new Date().toISOString();
                const end = features.window_end || new Date().toISOString();

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Network Performance Report\n`;
                csv += `# Generated At: ${new Date().toLocaleString()}\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;

                csv += `\n[SECTION] 1. BANDWIDTH & THROUGHPUT\n`;
                csv += "Metric,Value,Unit\n";
                csv += `Bandwidth Utilization,${calculateBandwidthUtilization(features)}%,Percentage\n`;
                csv += `Byte Rate,${formatBytes(features.byte_rate_bps || 0)}/s,Rate\n`;
                csv += `Packet Rate,${(features.packet_rate_pps || 0).toFixed(1)},Packets/sec\n`;
                csv += `Avg Packet Size,${(features.avg_packet_size || 0).toFixed(0)},Bytes\n`;

                csv += `\n[SECTION] 2. CONNECTION QUALITY\n`;
                csv += "Metric,Value,Status\n";
                csv += `SYN-ACK Ratio,${(features.syn_ack_ratio || 0).toFixed(2)},${features.syn_ack_ratio > 0.8 ? 'Healthy' : 'Degraded'}\n`;
                csv += `Inter-Arrival Time,${((features.inter_arrival_time_mean || 0) * 1000).toFixed(2)} ms,Latency Proxy\n`;
                csv += `Connection Failure Rate,${((features.connection_failure_rate || 0) * 100).toFixed(1)}%,${features.connection_failure_rate < 0.2 ? 'Good' : 'High Failures'}\n`;

                csv += `\n[SECTION] 3. TRAFFIC COMPOSITION\n`;
                csv += "Metric,Count\n";
                csv += `Unique Destinations,${features.unique_dst_ips || 0}\n`;
                csv += `Unique Ports Hit,${features.unique_dst_ports || 0}\n`;
                csv += `TCP Packets,${features.tcp_count || 0}\n`;
                csv += `UDP Packets,${features.udp_count || 0}\n`;

                downloadFile(csv, `performance_report_${Date.now()}.csv`, 'text/csv');
            } catch (error) {
                alert('Performance Export failed: ' + error.message);
                console.error(error);
            }
        }

        async function checkDBStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                const data = await response.json();

                const dot = document.getElementById('db-status-indicator');
                const text = document.getElementById('db-status-text');

                if (data.database_connected) {
                    dot.classList.remove('bg-red-500', 'bg-gray-500');
                    dot.classList.add('bg-green-500');
                    text.textContent = 'DB Connected';
                    text.classList.remove('text-red-400');
                    text.classList.add('text-green-400');
                } else {
                    throw new Error('Disconnected');
                }
            } catch (error) {
                const dot = document.getElementById('db-status-indicator');
                const text = document.getElementById('db-status-text');

                dot.classList.remove('bg-green-500', 'bg-gray-500');
                dot.classList.add('bg-red-500');
                text.textContent = 'DB Offline';
                text.classList.remove('text-green-400');
                text.classList.add('text-red-400');
            }
        }

        // Check DB Status every 30s
        checkDBStatus();
        setInterval(checkDBStatus, 30000);


        // ==================== PACKETS PAGE ====================
        async function loadPackets(page = 1) {
            if (page < 1) return;

            try {
                const response = await fetch(`${API_BASE_URL}/api/packets?page=${page}&limit=50`);
                const data = await response.json();

                if (!data.packets) {
                    console.error('No packets data received');
                    return;
                }

                currentPacketPage = page;

                // Update pagination info
                document.getElementById('page-info').textContent = `Page ${page} of ${data.total_pages}`;
                document.getElementById('prev-btn').disabled = page <= 1;
                document.getElementById('next-btn').disabled = page >= data.total_pages;

                // Render packets table
                const tbody = document.querySelector('#packets-page table tbody');
                if (!tbody) return;

                if (data.packets.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" class="text-center py-8 text-gray-500">No packets found</td></tr>';
                    return;
                }

                tbody.innerHTML = data.packets.map(p => {
                    const timestamp = new Date(p.timestamp * 1000).toLocaleString();
                    return `
                        <tr class="border-b border-gray-700 hover:bg-gray-750 transition-colors">
                            <td class="py-3 px-4 text-gray-400 text-xs">${timestamp}</td>
                            <td class="py-3 px-4 font-mono text-blue-300">${p.src_ip || '-'}</td>
                            <td class="py-3 px-4 font-mono text-green-300">${p.dst_ip || '-'}</td>
                            <td class="py-3 px-4">${p.protocol || '-'}</td>
                            <td class="py-3 px-4">${p.src_port || '-'}</td>
                            <td class="py-3 px-4">${p.dst_port || '-'}</td>
                            <td class="py-3 px-4">${p.length || 0}</td>
                            <td class="py-3 px-4 text-xs text-gray-400">${p.tcp_flags || '-'}</td>
                        </tr>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error loading packets:', error);
            }
        }

        // ========== REPORT GENERATORS & SPECIAL EXPORTS ==========
        let recentAlerts = [];

        // Helper: Download File
        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // 1. Analytics Report: CSV of Features
        async function generateAnalyticsReport() {
            try {
                // Ask user for preference
                const userIp = prompt("Enter IP address to generate specific report (or leave empty for Global Report):");

                let url = `${API_BASE_URL}/api/features`;
                let filename = `analytics_report_global_${Date.now()}.csv`;

                if (userIp && userIp.trim() !== "") {
                    const ip = userIp.trim();
                    url = `${API_BASE_URL}/api/features/ip/${ip}`;
                    filename = `analytics_report_${ip}_${Date.now()}.csv`;
                }

                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    alert(`Error: ${data.error}`);
                    return;
                }

                // Calculate Interval
                const start = data.window_start || new Date().toISOString();
                const end = data.window_end || new Date().toISOString();

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Analytics Features\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;
                csv += "Feature,Value\n"; // Header

                for (const [key, value] of Object.entries(data)) {
                    csv += `${key},${value}\n`;
                }

                downloadFile(csv, filename, 'text/csv');
            } catch (error) {
                alert('Failed to generate report: ' + error.message);
            }
        }

        // 2. Security Report: CSV Log of Alerts
        function generateSecurityReport() {
            if (!recentAlerts || recentAlerts.length === 0) {
                alert("No security alerts recorded in this session to export.");
                return;
            }

            // Calculate Interval
            const end = recentAlerts[0].timestamp || new Date().toISOString();
            const start = recentAlerts[recentAlerts.length - 1].timestamp || end;

            let csv = `# Generated By: NetGuardian Pro\n`;
            csv += `# Report Type: Security Incident Log\n`;
            csv += `# Data Interval: ${start} - ${end}\n`;
            csv += "Timestamp,AttackType,SourceIP,Confidence,Severity\n";

            recentAlerts.forEach(alert => {
                const time = alert.timestamp || new Date().toISOString();
                const type = (alert.attack_type || "Unknown").replace(/"/g, '""');
                const ip = alert.src_ip || "N/A";
                const conf = ((alert.confidence || 0) * 100).toFixed(1) + "%";
                const sev = alert.severity || "INFO";

                csv += `"${time}","${type}","${ip}","${conf}","${sev}"\n`;
            });

            downloadFile(csv, `security_log_${Date.now()}.csv`, 'text/csv');
        }

        // 3. Performance Report: CSV of Chart Data
        function generatePerformanceReport() {
            if (chartInstances['byteRateChart']) {
                const chart = chartInstances['byteRateChart'];
                const labels = chart.data.labels;
                const data = chart.data.datasets[0].data;

                if (labels.length === 0) {
                    alert("No data points available.");
                    return;
                }

                const start = labels[0];
                const end = labels[labels.length - 1];

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Performance Metrics\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;
                csv += "Timestamp,ByteRate(Bps)\n";

                labels.forEach((label, index) => {
                    csv += `${label},${data[index]}\n`;
                });

                downloadFile(csv, `performance_metrics_${Date.now()}.csv`, 'text/csv');
            } else {
                alert("Performance data not yet loaded. Please view the Performance tab first.");
            }
        }

        // 4. Packets Export: CSV of Raw Packets
        async function exportPackets() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/packets?limit=1000`);
                const data = await response.json();

                // Handle different response formats
                const packets = Array.isArray(data) ? data : (data.packets || []);

                if (!packets || packets.length === 0) {
                    alert("No packets found to export.");
                    return;
                }

                // Calculate Interval (Packets sorted DESC usually)
                const end = packets[0]?.timestamp || packets[0]?.captured_at || "N/A";
                const start = packets[packets.length - 1]?.timestamp || packets[packets.length - 1]?.captured_at || "N/A";

                let csv = `# Generated By: NetGuardian Pro\n`;
                csv += `# Report Type: Raw Packet Dump\n`;
                csv += `# Data Interval: ${start} - ${end}\n`;

                const headers = Object.keys(packets[0]).join(",");

                csv += headers + "\n";

                packets.forEach(row => {
                    const line = Object.values(row).map(v => {
                        // Escape quotes and commas
                        const s = String(v).replace(/"/g, '""');
                        return `"${s}"`;
                    }).join(",");
                    csv += line + "\n";
                });

                downloadFile(csv, `packet_capture_${Date.now()}.csv`, 'text/csv');
            } catch (error) {
                alert('Export failed: ' + error.message);
            }
        }

        // 5. Packet Search Filter
        function filterPacketsTable() {
            const input = document.getElementById("packetSearchInput");
            const filter = input.value.toUpperCase();
            const table = document.getElementById("packets-table");
            const tr = table.getElementsByTagName("tr");
            for (let i = 1; i < tr.length; i++) {
                let text = tr[i].textContent || tr[i].innerText;
                if (text.toUpperCase().indexOf(filter) > -1) {
                    tr[i].style.display = "";
                } else {
                    tr[i].style.display = "none";
                }
            }
        }

        // 6. Security UI Updaters
        function updateThreatLog(alert) {
            const tbody = document.getElementById('threat-log-body');
            if (!tbody) return;

            const row = document.createElement('tr');
            row.className = "border-b border-gray-700 hover:bg-gray-750 transition-colors";

            let statusColor = "text-yellow-400";
            if (alert.severity === 'CRITICAL') statusColor = "text-red-500 font-bold";
            else if (alert.severity === 'HIGH') statusColor = "text-orange-400";
            else if (alert.severity === 'LOW') statusColor = "text-blue-400";
            else if (alert.severity === 'INFO') statusColor = "text-green-400";

            row.innerHTML = `
                <td class="px-4 py-2 text-gray-400 whitespace-nowrap">${new Date().toLocaleTimeString()}</td>
                <td class="px-4 py-2 font-medium text-white">${alert.attack_type}</td>
                <td class="px-4 py-2 font-mono text-xs text-blue-300">${alert.src_ip}</td>
                <td class="px-4 py-2 text-gray-300">${(alert.confidence * 100).toFixed(0)}%</td>
                <td class="px-4 py-2 ${statusColor}">${alert.severity}</td>
            `;

            if (tbody.children[0] && tbody.children[0].innerText.includes("No threats")) {
                tbody.innerHTML = "";
            }

            tbody.insertBefore(row, tbody.firstChild);
            if (tbody.children.length > 50) tbody.removeChild(tbody.lastChild);
        }

        // 7. Update Security Alert Header
        function updateSecurityAlert(alert) {
            const alertDiv = document.getElementById('security-alert');
            const statusEl = document.getElementById('security-status');
            const messageEl = document.getElementById('security-message');
            const iconDiv = alertDiv.querySelector('.alert-icon');

            if (!alert || alert.attack_type === 'Normal' || alert.attack_type === 'normal') {
                // All clear
                alertDiv.className = 'bg-gradient-to-r from-green-900 to-green-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-green-700';
                iconDiv.className = 'alert-icon bg-green-500 p-3 rounded-lg';
                iconDiv.innerHTML = '<i data-feather="check-circle" class="w-8 h-8"></i>';
                statusEl.textContent = 'All Clear';
                messageEl.textContent = 'No threats detected. Network operating normally.';
            } else {
                // Attack detected
                const severity = alert.severity || 'HIGH';
                const confidence = ((alert.confidence || 0) * 100).toFixed(0);

                if (severity === 'CRITICAL') {
                    alertDiv.className = 'bg-gradient-to-r from-red-900 to-red-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-red-700 animate-pulse';
                    iconDiv.className = 'alert-icon bg-red-500 p-3 rounded-lg';
                } else if (severity === 'HIGH') {
                    alertDiv.className = 'bg-gradient-to-r from-orange-900 to-orange-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-orange-700';
                    iconDiv.className = 'alert-icon bg-orange-500 p-3 rounded-lg';
                } else {
                    alertDiv.className = 'bg-gradient-to-r from-yellow-900 to-yellow-800 rounded-xl p-6 mb-8 flex items-center space-x-4 border border-yellow-700';
                    iconDiv.className = 'alert-icon bg-yellow-500 p-3 rounded-lg';
                }

                iconDiv.innerHTML = '<i data-feather="alert-triangle" class="w-8 h-8"></i>';
                statusEl.textContent = `‚ö†Ô∏è ${alert.attack_type} Detected!`;
                messageEl.textContent = `Source: ${alert.src_ip || 'Unknown'} | Confidence: ${confidence}% | Severity: ${severity}`;
            }

            // Refresh feather icons
            feather.replace();
        }

        async function initializeDashboard() {
            await loadDashboard();
            await loadProtocolChart();
            await loadTrafficVolumeChart();
            await loadProtocolTrendChart();
            await loadPacketSizeChart();
            await loadTopSources();
            await loadTopDestinations();
            await loadTopPorts();
        }

        // Initialize dashboard data first
        initializeDashboard();

        // DB Status check function
        async function checkDBStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                const data = await response.json();
                const indicator = document.getElementById('db-status-indicator');
                const text = document.getElementById('db-status-text');

                if (data.database_connected) {
                    indicator.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse';
                    text.textContent = 'DB Connected';
                    text.className = 'text-xs text-green-400';
                } else {
                    indicator.className = 'w-2 h-2 bg-red-500 rounded-full';
                    text.textContent = 'DB Offline';
                    text.className = 'text-xs text-red-400';
                }
            } catch (error) {
                const indicator = document.getElementById('db-status-indicator');
                const text = document.getElementById('db-status-text');
                indicator.className = 'w-2 h-2 bg-red-500 rounded-full';
                text.textContent = 'DB Offline';
                text.className = 'text-xs text-red-400';
            }
        }

        // Check DB status initially and every 30 seconds
        checkDBStatus();
        setInterval(checkDBStatus, 30000);

        // Auto-refresh dashboard data every 10 seconds
        setInterval(() => {
            const activePage = document.querySelector('.page.active')?.id;
            if (activePage === 'dashboard-page') {
                loadDashboard();
                updateTimestamp();
            } else if (activePage === 'analytics-page') {
                loadAnalytics();
            } else if (activePage === 'security-page') {
                loadSecurity();
            } else if (activePage === 'performance-page') {
                loadPerformance();
            } else if (activePage === 'packets-page') {
                // Refresh current page of packets
                loadPackets(currentPacketPage || 1);
            }
        }, 5000);

        // Initialize WebSocket connection for real-time updates
        const dashboardWS = new DashboardWebSocket();
        dashboardWS.connect();

        // Keep WebSocket alive with periodic pings
        setInterval(() => {
            if (dashboardWS.isConnected) {
                dashboardWS.ping();
            }
        }, 30000);

        console.log('‚úÖ NetGuardian Pro initialized with auto-refresh (10s interval)');
        console.log('üì° API URL:', API_BASE_URL);

        // ========== TELEGRAM BOT FUNCTIONS ==========

        async function checkTelegramStatus() {
            const statusDiv = document.getElementById('webhook-status');
            const indicator = document.getElementById('bot-status-indicator');
            const statusText = document.getElementById('bot-status-text');

            statusDiv.innerHTML = '<span class="text-yellow-400">‚è≥ Checking bot status...</span>';

            try {
                const response = await fetch(`${API_BASE_URL}/api/telegram/status`);
                const data = await response.json();

                if (data.ok) {
                    indicator.className = 'w-3 h-3 bg-green-500 rounded-full animate-pulse';
                    statusText.textContent = 'Bot Active';
                    statusText.className = 'text-sm text-green-400';

                    document.getElementById('bot-name').textContent = data.bot_name;
                    document.getElementById('bot-username').textContent = '@' + data.bot_username;

                    statusDiv.innerHTML = '<span class="text-green-400">‚úÖ Bot token is valid!</span>';
                } else {
                    indicator.className = 'w-3 h-3 bg-red-500 rounded-full';
                    statusText.textContent = 'Bot Error';
                    statusText.className = 'text-sm text-red-400';
                    statusDiv.innerHTML = `<span class="text-red-400">‚ùå ${data.error}</span>`;
                }
            } catch (error) {
                indicator.className = 'w-3 h-3 bg-red-500 rounded-full';
                statusText.textContent = 'Offline';
                statusText.className = 'text-sm text-red-400';
                statusDiv.innerHTML = `<span class="text-red-400">‚ùå Failed to check: ${error.message}</span>`;
            }
        }

        async function autoSetupTelegram() {
            const statusDiv = document.getElementById('webhook-status');
            const webhookActive = document.getElementById('webhook-active');

            statusDiv.innerHTML = '<span class="text-yellow-400">üöÄ Starting ngrok and setting webhook...</span>';

            try {
                const response = await fetch(`${API_BASE_URL}/api/telegram/auto-setup`, {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    statusDiv.innerHTML = `<span class="text-green-400">‚úÖ ${data.message}</span><br><span class="text-xs text-gray-400">${data.ngrok_url}</span>`;
                    webhookActive.textContent = '‚úÖ Active';
                    webhookActive.className = 'text-xs text-green-400';

                    // Also check bot status to update the header
                    checkTelegramStatus();
                } else {
                    statusDiv.innerHTML = `<span class="text-red-400">‚ùå ${data.error}</span>`;
                    webhookActive.textContent = 'Failed';
                    webhookActive.className = 'text-xs text-red-400';
                }
            } catch (error) {
                statusDiv.innerHTML = `<span class="text-red-400">‚ùå Setup failed: ${error.message}</span>`;
            }
        }

        async function broadcastAlert() {
            const message = document.getElementById('alertMessage').value;
            const statusDiv = document.getElementById('alert-status');

            if (!message.trim()) {
                statusDiv.innerHTML = '<span class="text-yellow-400">‚ö†Ô∏è Please enter a message</span>';
                return;
            }

            statusDiv.innerHTML = '<span class="text-yellow-400">üì§ Sending...</span>';

            try {
                // Use the telegram_bot broadcast endpoint (port 5000 if running separately)
                // Or we can add a broadcast endpoint to main.py
                const response = await fetch(`${API_BASE_URL}/api/telegram/broadcast`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });
                const data = await response.json();

                if (data.sent_to !== undefined) {
                    statusDiv.innerHTML = `<span class="text-green-400">‚úÖ Sent to ${data.sent_to} users</span>`;
                    document.getElementById('alertMessage').value = '';
                } else if (data.error) {
                    statusDiv.innerHTML = `<span class="text-red-400">‚ùå ${data.error}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<span class="text-red-400">‚ùå Failed: ${error.message}</span>`;
            }
        }

        // Check Telegram status on page load (Security page)
        document.addEventListener('DOMContentLoaded', () => {
            // Delay to ensure page is fully loaded
            setTimeout(checkTelegramStatus, 2000);
        });
    </script>
</body>

</html>